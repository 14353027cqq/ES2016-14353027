## Lab4-死锁

> 陈绮晴14353027

1. #### 死锁停在第几次的截图

   ![](http://i1.piimg.com/567571/47e2f0e9856c3a34.png)

2. #### 产生死锁的四个必要条件

   * 互斥条件：一个资源每次只能被一个进程使用
   * 请求与保持条件：一个进程因请求资源而阻塞时，对已经获取的资源保持不放
   * 不剥夺条件（非抢占）：进程已获得的资源，在未使用完之前不能强行剥夺
   * 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系

3. #### 实验步骤

   * 创建一个文件Deadlock.java，代码如下图所示

     ![](http://p1.bqimg.com/567571/2e18c68c68214dca.png)

   * 在命令行运行javac Deadlock.java

   * 创建一个Deadlock.sh文件，代码如下图所示(让上面的代码跑1000次)

     ![](http://p1.bqimg.com/567571/cdd103fdb9de3650.png)

   * 在命令行运行bash Deadlock.sh

4. #### 对上述程序产生死锁的解释

   * 首先我们要知道关键字synchronized的意义。当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。当一个线程访问object的一个synchronized同步代码块或同步方法时，其他线程对object中所有其他synchronized同步代码块或同步方法的访问将被阻塞。
   * 代码首先执行main函数，main函数是新建了一个Deadlock，所以代码跑到Deadlock的构造函数中，就相当于正在运行主线程main。然后Deadlock运行的时候新创建了一个子线程t，然后运行t.start()，当运行这句话之后，线程t就被插入到调度队列中，所以现在等待队列中有线程t。接着运行while(count-->0)，这里相当于在消耗运行主线程的时间片，当差不多把主线程的时间片运行完了之后，执行a.methodA(b)，然后就有可能因为时间片被消耗完了，指针就停在了methodA函数或者b.last函数上，也就是a和b都被锁住了。
   * 接着Deadlock()运行完之后，由于Deadlock这个类实现了runnable接口，runnable这个接口要求run方法，因此会调用run()函数，执行b.methodB(a)，但是由于现在a和b都被锁住了，所以就出现了死锁。
   * 增加运行次数和while(count-->0)都是为了增加出现死锁的概率。